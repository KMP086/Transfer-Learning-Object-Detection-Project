#set imports
import cv2, time, os, tensorflow as tf
import numpy as np
from tensorflow.python.keras.utils.data_utils import get_file
np.random.seed(123) #color random change

class Object_Detector:
    def __init__(self):
        pass
    
    def readclasses(self, classesfilepath):
        with open(classesfilepath, 'r') as f:
            self.classesList = f.read().splitlines()
            
        #color each boxes
        self.colorlist = np.random.uniform(low=0, high=255, size=(len(self.classesList),3))
        
        print(len(self.classesList),len(self.colorlist))

    def downloadmodel(self, modelurl):
        filename = os.path.basename(modelurl)
        self.modelname = filename[:filename.index('.')]
        
        print("File Name: " + filename)
        print("Model Name: " + self.modelname)
        
        self.cachedir="./Trained_Model" 
                 
        os.makedirs(self.cachedir, exist_ok=True)
        get_file(fname=filename,
                 origin=modelurl,
                 cache_dir=self.cachedir,
                 cache_subdir="checkpoints",
                 extract=True)
        
    def loadmodel(self, imagemodel):
        
        #print("Loading Model: " + self.modelname)
        model_file_path = imagemodel
        print(os.path.exists(model_file_path))        
        print(model_file_path)
        tf.keras.backend.clear_session() # Resets all state generated by Keras.
        self.model = tf.saved_model.load(model_file_path)
        print("Model " + self.modelname + " loaded successfully")
    

    def create_bounding_box(self, image, threshold):
        inputTensor = cv2.cvtColor(image.copy(), cv2.COLOR_BGR2RGB)
        inputTensor = tf.convert_to_tensor(inputTensor, dtype=tf.uint8)
        inputTensor = inputTensor[tf.newaxis,...]

        detections = self.model(inputTensor)

        bboxs = detections["detection_boxes"][0].numpy()
        
        classindexes = detections["detection_classes"][0].numpy().astype(np.int32)
        classscores = detections["detection_scores"][0].numpy()

        imH, imW, imC = image.shape #image height, weight , and width
        
        # max_output_size=50 ~~ 50 boxes
        bboxidx = tf.image.non_max_suppression(bboxs, classscores, max_output_size=50, 
        iou_threshold=0.5, score_threshold=0.5)

        print(bboxidx)    
        if len(bboxidx) !=0:
            for i in bboxidx:
                bbox = tuple(bboxs[i].tolist())
                classconfidence = round(100*classscores[i])
                classindex = classindexes[i]

                classlabeltext = self.classesList[classindex]
                classcolor = self.colorlist[classindex]

                displayText = '{}: {}%'.format(classlabeltext, classconfidence)

                ymin, xmin, ymax, xmax = bbox

                xmin, xmax, ymin, ymax = (xmin * imW, xmax * imW, ymin * imH, ymax * imH)
                xmin, xmax, ymin, ymax = int(xmin), int(xmax), int(ymin), int(ymax)

                cv2.rectangle(image,(xmin, ymin), (xmax, ymax), color=classcolor, thickness=1)
                cv2.putText(image, displayText, (xmin, ymin -10), cv2.FONT_HERSHEY_PLAIN, 1, classcolor, 2)
                ##Border Top####################################################################
                lineWidth = min(int((xmax - xmin) * 0.2), int((ymax - ymin) * 0.2))
                ##Left##
                cv2.line(image, (xmin, ymin), (xmin + lineWidth, ymin), classcolor, thickness=5)
                cv2.line(image, (xmin, ymin), (xmin, ymin + lineWidth), classcolor, thickness=5)
                ##Right##
                cv2.line(image, (xmax, ymin), (xmax - lineWidth, ymin), classcolor, thickness=5)
                cv2.line(image, (xmax, ymin), (xmax, ymin + lineWidth), classcolor, thickness=5)
                ##Border End#####################################################################
                ##Left##
                cv2.line(image, (xmin, ymax), (xmin + lineWidth, ymax), classcolor, thickness=5)
                cv2.line(image, (xmin, ymax), (xmin, ymax - lineWidth), classcolor, thickness=5)
                ##Right##
                cv2.line(image, (xmax, ymax), (xmax - lineWidth, ymax), classcolor, thickness=5)
                cv2.line(image, (xmax, ymax), (xmax, ymax - lineWidth), classcolor, thickness=5)

        return image

            
    def kim_pambid_predict_image(self, imagepath, threshold=0.5):
        images = cv2.imread(imagepath)
        bboximage=self.create_bounding_box(images, threshold)    
        cv2.imwrite(self.modelname + ".jpg", bboximage)
        cv2.imshow("Result", bboximage)
        cv2.waitKey(0) #wait for 10 nano secs
        cv2.destroyAllWindows()
        
    def kim_pambid_predict_video(self, videopath, threshold=0.5):
        cap = cv2.VideoCapture(videopath)
        if(cap.isOpened() == False):
          print("Error opening file...")
          return
        
        (success, image) = cap.read()  
        starttime =0    
        while success:
            currenttime = time.time()
            
            fps = 1/(currenttime - starttime)
            starttime = currenttime
            
            bboximage = self.create_bounding_box(image, threshold) 
            cv2.putText(bboximage, 
                        "FPS: " + str(int(fps)), 
                        (20, 70), 
                        cv2.FONT_HERSHEY_PLAIN,2,
                        (0, 255, 0), 2)   
            cv2.imshow("Result", bboximage)
            
            key = cv2.waitKey(1) & 0xFF
            if key == ord("q"):
                break
            (success, image) = cap.read()
        cv2.destroyAllWindows()